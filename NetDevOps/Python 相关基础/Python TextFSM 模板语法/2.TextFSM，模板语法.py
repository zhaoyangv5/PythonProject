'''
1、TextFSM语法概述

我们将按照TextFSM文档介绍模板的语法，后面会结合具体的例子。在实际例子中，如果你想了解具体参数含义和如何应用，可以反复翻阅本文，加深理解。

TextFSM 模板描述了数据是被如何处理的过程。每个模板包括两个部分：

变量定义（value definitions (or variable definitions)） - 每个变量描述了数据提取结果表格视图中的列。
状态定义（state definitions） - 具体匹配规则部分。
我们还是以traceroute做演示。本文有且只有这个例子，我建议用txt复制下来，前后对照。

Value ID (\d+)
Value Hop (\d+(\.\d+){3})

Start
  ^ ${ID} ${Hop} -> Record
小结一下：到这里您需要记住，TextFSM有两个区域，一个叫“变量定义”，一个叫“状态定义”。

2、变量定义

2.1 变量定义（Value definition）

请先看示例模板的前两行，只有在这个区域，我们才能定义变量，也只能定义变量。当然，在这里加点注释也是可以的。定义过程不能包含空字符，因为如空字符，TextFSM 会当作定义终结。

变量定义格式如下：

Value [option[,option...]] name regex
变量描述的语法（只看大概，得结合实例才能清晰理解）：

2.2 Value - 关键字

必须，用于声明创建一个变量。

这个没啥好说的，就是要定义一个变量值的时候，我们必须这么写一个Value在前面。

2.3 option - 选项位

可选，指明定义变量将以什么“姿态”来协动上下文。我们现在先大概了解选项位有如下几个枚举值即可。后面例子用到了我们就自然清晰了，届时再回过头来理解感悟。选项位可以有多个，用逗号隔开，中间不能带空格。上面示例中没有使用到选项位，所以看不到这些字眼。

Filldown
如果上一轮匹配已结束，变量没有明确指定要清除的话，该变量值会被带入下一轮；下一轮匹配过程中，这个变量如被匹配刷新，则用新的值；如未被匹配刷新，则该变量值会被继续带入再下一轮。
Key
明确该字段包含唯一的字符串标识。
Required
一轮匹配过程，该变量必须匹配到，其结果才会被记录。
List
TextFSM模板默认处理过程是下次匹配会覆盖掉上一轮的匹配值，如果使用了List选项值，则每次匹配会以列表追加元素的形式，往列表尾部逐一追加匹配值。
Fillup
与Filldown相似，但往上填充，直到变量值非空。该选项值与Required互斥。
2.4 name - 变量名

换个数据表说法【字段】，再换个EXCEL说法【列名】，如上面例子， "ID" ，"Hop"。保留字段不能作为变量名。
2.5 regex - 变量表达式

描述定义变量的正则表达式，()括号括起来部分，如上面例子，"\d+" ，"\d+(\.\d+){3}"。
小结一下：不要反复抠字眼试图完全理解，特别是option选项位部分，得结合具体例子才容易清晰。

3、状态定义

“变量定义”后，我们转入“状态定义”。

3.1 状态定义（State definition）

每个状态定义必须与之前部分隔开至少一个空行。如上面例子，"Start" 就是一个状态，它跟变量定义之间，要隔开至少一个空行。
第一行为状态的名字，如上面例子，"Start" 就是状态名。
接下来的每一行就是规则描述（rules）了。如上面例子，" ^ ${ID} ${Hop} -> Record"就是一条规则，规则可以有多条。本例只有一行规则。具体我们来看下这条规则，它以1个或2个空格开头，紧跟着来一个"^"符号。固定格式照抄即可，不要问为什么？我也讲不清为什么= =。
起始状态一般都是"Start"。这里参考书《Python for network engineers》原文有句“Input data is compared to the current state but rule line can specify that you want to go to a different state."因为上面例子只有一个状态Start，这里飘出来说另一个不同的状态，显然“超纲”了。我们就先直接过，不机械理解，后面结合实际例子再回过头来感悟。日常学习也如此，不要在哪里卡到了就怕了。我们借鉴下陶渊明《五柳先生传》“好读书，不求甚解”，直接过，等到实际接触了，再“每有会意，便欣然忘食”哈。

【原文】Input data is compared to the current state but rule line can specify that you want to go to a different state.
【翻译】输入数据在当前状态下进行匹配，但是该状态下的规则可以设置状态跳转，跳去你想要的状态。
从"Start"状态出发，逐行规则检查，直到“EOF”标识（文末标识），后者状态会指向“End”状态。上面例子只有一个"Start"状态，显然就是匹配到文末结束。

3.2 保留状态（Reserved states）

TextFSM模板有3个保留状态。

Start - 这个状态必须指定，否则模板无法工作。上面例子就只有"Start"状态。
End - 这个状态表明输入的字符串已经完成处理了，但此后不执行"EOF"状态。（不要在这里纠结，你得看完后面的，再回过头来才能理解，所以读一下后，就过过过。）
EOF - 这个状态是隐式指定，也就是它不一定呈现出来。换句话说就是你不用指定，它默默会给你添加。它是干嘛用的？拿上面例子来说，就是"Start"状态开始后，按照规则（rules）处理数据，处理到文末，自动就到达了"EOF"状态，结束。所以上面例子我们不用专门写"EOF"状态也能顺利结束的原因就在这里。
看了"EOF"状态的表述，回过头看"End"状态的描述，应该可以理解了吧？它的意思是，如果你还没到达文末呢，你就想先结束了，比如你需要调测模板，那你就来个"End"状态（编程属于叫“做个断点”），它就不会非要处理到文末"EOF"状态为止。这好比你是司机，遇到紧急情况，合规情况下该停车时你随时能刹车。

如果你非要让这个隐式状态给显式出来，那就这么写：

EOF
  ^.* -> Record
这么写"EOF"状态会在结束前把当前的字符串通通都给记录下来，这是一个默认动作。如果你不想要做这个默认动作，那你必须显式指定"EOF"状态，即结束但不做记录，那就这么写：

EOF
小结一下：上面例子虽然只有一个"Start"状态，但它隐含了另一个"EOF"状态，也就是我们可以理解TextFSM是有多状态的。那么我们再回过头来【3、状态定义-规则描述】中提及的参考书《Python for network engineers》原文有句“Input data is compared to the current state but rule line can specify that you want to go to a different state."应该就多少能理解一点了。我试着解释下：输入数据会在当前状态中进行比对，但是通过行中规则（rule line），你可以“为所欲为”地跳转到其它想要状态。

4 状态规则（State rules）

状态定义后，每个状态都会包含一条或多条规则。

TextFSM接收输入字符串后，依据逐条规则处理该字符串。
一旦某条规则匹配，则该规则中的动作（默认是next）将被执行，接着TextFSM接收新的字符串，并从头开始匹配，重复执行。
【举例，后面慢慢结合例子再理解】规则改一下动作（continue，需手动指明）将被执行，则还是原来的字符串，继续往下进行规则匹配。
状态规则语法如下：

  ^regex [-> action]
规则中：

每条规则必须以两个空格和^脱字符开始，脱字符^必须明确指出来。
正则表达式中可以嵌入变量。
指定变量有两种形式：$ValueName 和 ${ValueName} （推荐用这种）。
在规则中，你放入的变量会被替换成定义它的正则表达式。
如果你想明确指定行尾，则可以使用$$。
4.1 规则内的动作（Action in rules）

在规则后面，仅接着就是动作。

动作与规则之间，必须由 -> 符号进行连接。
动作可以分成三类，简单标记为 L.R.S
L - LineAction ： 这个动作用来控制待匹配字符串（即输入的字符串）。
R - RecordAction ： 这个动作用来控制如何收集已定义的变量。
S - StateTransition ： 这个动作用来控制状态的跳转。
我们啥都不写的话，缺省情况下，动作为 Next.NoRecord。
Next 是针对待匹配字符串（输入的字符串），下一行。
NoRecord 是针对前面定义的变量，不提取不记录。
4.2 动作L.R.S详解


Line Actions 这是处理待匹配文本的，待匹配文本是一行一行进来的，所以叫行（Line）动作。
Next - 如果规则匹配中了，读取下一行待匹配字符串，整个匹配规则重新回归第一行开始往下匹配。如不明确指定，默认就是这个动作。
Continue - 如果规则匹配中了，在“处理待匹配字符串（输入的字符串）”这个维度上，当作没匹配中进行处理，该干嘛还干嘛，该匹配下一行规则就继续匹配。（假装啥事都没发生。）

Record Action 这是处理变量的。我们可以在Line动作后指定Record动作，用一个点号进行连接。
NoRecord - 啥事不干。这是一个默认动作。
Record - 变量结果执行提取记录，之后所有变量重置（不包括带Filldown选项的变量）。
Clear - 变量结果不执行提取记录，所有变量重置（不包括带Filldown选项的变量）。
Clearall - 变量结果不执行提取记录，所有变量重置。
在一行规则匹配后，倘若需要同时执行Line动作和Record动作，此时就需要用点号连接，如Continue.Record；倘若只需要执行其中一个动作，就不需要点符号了。


State Transition 这是处理状态跳转的。
所跳转的状态必须是TextFSM预设或用户自定义的，不能跳转到一个未定义的状态去。
如果待匹配字符串（输入字符串）命中规则
所有动作都执行。
读取下一行待输入文本。
当前状态跳转至指向的状态，并继续执行匹配。
如果规则包含了Continue动作，则这规则内无法进行状态跳转。另外设置跳转规则的时候，需要避免状态间来回跳转，进入死循环。


Error Action 这是处理错误的。
Error 发生错误时候，停止所有行处理，丢弃所有变量收集，返回一个错误表达式。其语法如下：
^regex -> Error [word|"string"]
5、其它

考虑到可能有些童鞋们没怎么接触过正则表达式，本文涉及的正则表达式解释一下：

【\d+】 \d匹配任何十进制数字，相当于类 [0-9]；+匹配前面的子表达式（这里就是\d）一次或多次，等价于 {1,}。

【\.】.特殊字符，\斜杆让.恢复成只匹配.点字符。具体到上面例子，就是匹配IP地址中的.点。

【{3} 】前边的子表达式 \.\d+ 匹配 3 次，因为它们被用括号括起来，所以叫做一个子表达式。

【.】表示匹配除了换行符外的任何字符。（一般情况下）

【*】匹配前面的子表达式零次或多次，等价于 {0,}。

具体到本文例子：

【Value ID (\d+)】定义一个叫ID的变量，可匹配0，也可匹配1，也可匹配11，也可匹配123等。

【Value Hop (\d+(\.\d+){3}) 】定义一个叫Hop的变量，匹配 IP 地址（粗匹配而已，就是这一段如果是 IP 地址是能匹配到的，但是有些不是IP地址的，也能被匹配到。比如192.168.1.1可以匹配到，它也是一个IP地址，333.333.444.444也可以匹配到，但它不是一个IP地址。所以说是粗匹配。）

【.*】：任意非空字符。
'''