"""
使用Value定义了要提取的字段之后，我们需要定义State，State也可以定义1个或者多个，它们之间用空白行隔开。第一行是State的名称，
接下来换行，是众多解析规则Rule。一个State的定义格式如下：

stateName
 ^rule
 ^rule
 ...
每个rule必须先以1-2个空格开头，然后以紧接"^"（正则中代表字符串文本的开头，对应的是每行文本的开头）。

保留的State

State是有限状态自动机中“状态”。名字我们可以根据自己的使用习惯去命名，但是不能保留的State名字重复。

TextFSM一共有三个保留状态Start、EOF和End

Start

TextFSM必须以“Start”状态开始

EOF

EOF代表的是End Of File状态，即文本配置已经读取到结尾，已经读取结束。

当输入（文本）读取到EOF的时候，TextFSM进入EOF状态，它是一个保留状态，同时默认是隐式的，即我们只需写一个Start进行识别记录，
当读到文本末尾的时候，TextFSM会默认进入EOF状态，将最后识别到的一条record记录追加到待返回的数据中并结束。
这些都是TextFSM自动帮我们完成的。我们也可以显示地调用进入EOF状态，这个时候，TextFSM不会将刚识别到的record追加到待返回的列表数据中。

这种显示调用分两种情况（我们这里先系统地提出，在后续的实战中会详细讲解）：

在rule中显示进行状态转移，指向隐藏的EOF状态，这种情况最常见，且更加有意义。
当我们发现新型都识别完成，无需继续识别匹配的时候，我们可以显示的调用EOF状态（这种显示的调用实际是利用了rule中的状态转移Action，后续会讲），
这样可以节约计算资源，尤其是在display current-configuration这种回显特别长的文本中，只寻找一小段配置的信息，
当识别提取并记录后，我们可以及时地调用EOF状态（实际是一次状态转移）显示地结束状态机，来节省资源，设想一段配置有几万行，
而我们要识别的内容很靠前，后面的文本没有继续识别的必要，所以可以显式使用EOF及时结束。

Value version (\S+)
Value no_value (\S+)

Start
 ^VRP \(R\) software, Version ${version} -> Record EOF
我们以之前的display version文本为示例，我们识别出软件包版本后进行记录并进入EOF状态终止状态机（我们还无需关注Rule的写法，后续会详细展开）。
这样状态机读取到软件版本那行文本并匹配到Start状态的第一条Rule的时候，提取了软件版本信息，及时得进行了记录，并进入EOF终止了继续匹配。
这种写法更有效率，且某种情况下，不会过多的匹配到后面的一些干扰文本。

只在最后添加EOF状态，在rule中不进行状态转移。
这种情况使用场景不高，主要针对的是Filldown产生的一些“干扰”，之前讲过Filldown的可选项逻辑，比如堆叠的网络设备，或者板卡的一些表项都会有某个值为空，
但是TextFSM的机制会先生成一个新的字典，同时把Filldown的那个字段根据之前的值填充进去，会产生一个只有Filldown字段的、其他字段均为空的字典，
这种情况下可以考虑在最后添加一个EOF状态，TextFSM会按照EOF的逻辑不把最后一条目前识别到的记录追加到待返回的列表数据中。

End

End其官方描述为：一个保留状态，会终止输入文本行，且不执行EOF状态

官方描述中，有一点比较明确，一点比较模糊。明确的是它会终止文本的输入。模糊的是它不执行EOF状态是什么意思？
笔者结合textfsm1.1.3的源代码发现，它其实等价于进行EOF的场景1，使用状态转移进入EOF状态，提前结束文本的继续匹配动作。


"""